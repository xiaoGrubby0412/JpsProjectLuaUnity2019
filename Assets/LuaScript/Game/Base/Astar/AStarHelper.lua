---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangman.
--- DateTime: 2021/7/16 11:49
---
local APriorityQueue = require("Game.Base.Astar.APriorityQueue")

local Dir = { { 0, -1 }, { 0, 1 }, { -1, 0 }, { 1, 0 }, { -1, -1 }, { 1, -1 }, { 1, 1 }, { -1, 1 } }
local KeyRoot = 65536
---@class AStarHelper
---@field currentStep number
---@field maxStep number
---@field endX number
---@field endY number
---@field finalNode ANode
---@field pathList number[]
---@field pathListV2 Vector2[]
---@field closeDict table
---@field openDict table
---@field sortedOpenQue APriorityQueue
---@field G number
---@field aMapData AMapDataBase
local AStarHelper = Class("AStarHelper")

---ctor
---@param aMapData AMapDataBase
function AStarHelper:ctor(aMapData)
    self.sortedOpenQue = APriorityQueue.New()
    self.openDict = {}
    self.closeDict = {}
    self.aMapData = aMapData
end

---FindPath
---@param startX number 开始X
---@param startY number 开始Y
---@param endX number 结束X 
---@param endY number 结束Y 
---@param p_maxStep number 寻路最大次数
---@param G number 减速系数
---@param ifNum boolean 是否返回数字类型
---@param ifFlyd boolean 是否平滑 nil默认为 平滑
---@param flydNum number 平滑长度
---@param isfour_road boolean @四方向寻路
function AStarHelper:FindPath(startX, startY, endX, endY, p_maxStep, G, ifNum, ifFlyd, flydNum, isfour_road)
    startX = Mathf.Floor(startX + 0.5)
    startY = Mathf.Floor(startY + 0.5)
    endX = Mathf.Floor(endX + 0.5)
    endY = Mathf.Floor(endY + 0.5)
    if self.aMapData:IsBlock(startX, startY) then
        PrintError("startX startY is Block !!! startX == " .. startX .. " startY == " .. startY)
        return nil
    end

    if self.aMapData:IsBlock(endX, endY) then
        PrintError("endX endY is Block !!! endX == " .. endX .. " endY == " .. endY)
        return nil
    end
    
    if p_maxStep == nil or p_maxStep < 1 then
        p_maxStep = self.aMapData.mapWidth * self.aMapData.mapHeight
    end

    self:Init(startX, startY, endX, endY, p_maxStep, G)
    self:StartFind(isfour_road)
    if self.finalNode == nil then
        print("no path found return nil curStep == " .. self.currentStep .. " PoolSize == " .. ANodePoolManager.size .. " OpenSize == " .. self.sortedOpenQue.count .. " OpenCount == " .. self.openCount .. " CloseCount == " .. self.closeCount)
        return nil
    else
        --print("curStep == " .. self.currentStep .. " ANodePoolSize == " .. ANodePoolManager.size .. " OpenSize == " .. self.sortedOpenQue.count .. " OpenCount == " .. self.openCount .. " CloseCount == " .. self.closeCount)
        self:NodeToList()
        if ifFlyd == nil or ifFlyd then
            self.pathList = AFlydSmoothManager:GetSmoothList(self.pathList, 65536, flydNum, self.aMapData)
        end

        if ifNum then
            return self.pathList
        else
            ---@type Vector2[]
            self.pathListV2 = {}
            for i = 1, #self.pathList - 2, 3 do
                table.insert(self.pathListV2, Vector2.New(self.pathList[i] / 10, self.pathList[i + 2] / 10))
            end
            return self.pathListV2
        end
    end
end

function AStarHelper:Init(startX, startY, endX, endY, p_maxStep, G)
    self.maxStep = p_maxStep
    self.G = G
    self.currentStep = 0
    self.finalNode = nil
    self.pathList = nil
    self.pathListV2 = nil
    for i = 0, self.sortedOpenQue.count - 1 do
        ANodePoolManager:PushFreeNodeToPool(self.sortedOpenQue.head[i])
    end

    self.sortedOpenQue:Clear()
    self.openDict = {}

    for k, v in pairs(self.closeDict) do
        ANodePoolManager:PushFreeNodeToPool(v)
    end
    self.closeDict = {}
    self.closeCount = 0
    self.openCount = 0

    local startNode = ANodePoolManager:GetFreeNode()
    startNode.X = startX
    startNode.Y = startY
    startNode.Parent = nil

    self.endX = endX
    self.endY = endY

    --print("startNode.x == " .. startNode.X .. " startNode.y == " .. startNode.Y .. " endX == " .. self.endX .. " endY == " .. self.endY)

    startNode.G = 0
    startNode.H = self:GetNodeH(startX, startY, endX, endY)
    startNode.F = startNode.G + startNode.H
    startNode.NodeType = self.aMapData:GetMapDataType(startX, startY)
    self.sortedOpenQue:Push(startNode)
    local key = startX + (startY * KeyRoot)
    self.openDict[key] = startNode
    self.openCount = self.openCount + 1
end

function AStarHelper:GetNodeH(nodeX, nodeY, endX, endY)
    --local nodeH = 10 * (math.abs(endX - nodeX) + math.abs(endY - nodeY))

    local xm = math.abs(endX - nodeX)
    local ym = math.abs(endY - nodeY)
    local nodeH = math.floor(10 * math.sqrt(xm * xm + ym * ym));
    --print("X == " .. nodeX .. " Y == " .. nodeY .. " return nodeH == " .. nodeH)
    return nodeH
end

---@param isfour_road boolean @是否是四方向寻路
function AStarHelper:StartFind(isfour_road)
    while (self.sortedOpenQue.count > 0 and self.currentStep <= self.maxStep) do
        local fNode = self.sortedOpenQue:Pop()
        --print("fNode X == " .. fNode.X .. " Y == " .. fNode.Y)

        local key = fNode.X + (fNode.Y * KeyRoot)
        if self.openDict[key] ~= nil then
            self.openDict[key] = nil
            self.openCount = self.openCount - 1
        end

        self.closeDict[key] = fNode
        self.closeCount = self.closeCount + 1
        self.currentStep = self.currentStep + 1

        if fNode.X == self.endX and fNode.Y == self.endY then
            self.finalNode = fNode
            break
        end
        
        local for_param = 8
        if isfour_road then
            for_param = 4
        end
        
        for i = 1, for_param do
            
            repeat
                local nodeX = fNode.X + Dir[i][1]
                local nodeY = fNode.Y + Dir[i][2]

                if self.aMapData:IsBlock(nodeX, nodeY) then
                    break
                end

                if i > 4 and ((self.aMapData:IsBlock(fNode.X, nodeY)) or (self.aMapData:IsBlock(nodeX, fNode.Y))) then
                    break
                end

                local key1 = nodeX + (nodeY * KeyRoot)
                if self.closeDict[key1] then
                    break
                end

                local nodeG
                local length
                if i < 5 then
                    length = 10
                else
                    length = 14
                end

                local nodeType = self.aMapData:GetMapDataType(nodeX, nodeY)
                if nodeType == AMapDataType.SlowDown then
                    nodeG = fNode.G + length * self.G
                else
                    nodeG = fNode.G + length
                end

                local nodeH = self:GetNodeH(nodeX, nodeY, self.endX, self.endY)
                local nodeF = nodeG + nodeH

                if self.openDict[key1] ~= nil then
                    local sortK = -1
                    local ifSetK = false
                    for k = 0, self.sortedOpenQue.count - 1, 1 do
                        local nn = self.sortedOpenQue.head[k]
                        if nodeX == nn.X and nodeY == nn.Y and nodeG < nn.G then
                            if ifSetK then
                                print("ifSetK == True ..........................................")
                            end
                            nn.G = nodeG
                            nn.F = nodeF
                            nn.Parent = fNode
                            sortK = k
                            ifSetK = true
                            break
                        end
                    end

                    if sortK ~= -1 then
                        self.sortedOpenQue:Sort(sortK)
                    end
                    break
                end

                local curNode = ANodePoolManager:GetFreeNode()
                curNode.X = nodeX
                curNode.Y = nodeY
                curNode.G = nodeG
                curNode.H = nodeH
                curNode.F = nodeF
                curNode.NodeType = self.aMapData:GetMapDataType(curNode.X, curNode.Y)
                curNode.Parent = fNode
                self.sortedOpenQue:Push(curNode)

                local curKey = nodeX + (nodeY * KeyRoot)
                self.openDict[curKey] = curNode
                self.openCount = self.openCount + 1
            until true
        end
    end
end

function AStarHelper:NodeToList()
    self.pathList = {}
    local cur = self.finalNode
    --local finalG = self.finalNode.G
    --local num = 0
    --local numSlow = 0
    --local numNormal = 0

    while (cur ~= nil) do
        table.insert(self.pathList, 1, cur.X * 10)
        table.insert(self.pathList, 2, 0)
        table.insert(self.pathList, 3, cur.Y * 10)

        --num = num + 1
        --if cur.NodeType == AMapDataType.SlowDown then
        --    numSlow = numSlow + 1
        --elseif cur.NodeType == AMapDataType.Normal then
        --    numNormal = numNormal + 1
        --else
        --    print("Error!!!!!!!!!!!!!!!!!!!!!!!!!!!! type == " .. cur.NodeType)
        --end
        cur = cur.Parent

    end

    --print("final node.G == " .. tostring(finalG) .. " all num == " .. tostring(num) .. " numSlow == " .. tostring(numSlow) .. " numNormal == " .. tostring(numNormal))
end

---@type AStarHelper
return AStarHelper 




