---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wangman.
--- DateTime: 2021/7/20 14:32
---

---@type APoint2
local APoint2 = require("Game.Base.Astar.Line.APoint2")
local AFractionV2 = require("Game.Base.Astar.Line.AFractionV2")

---@class AFlydSmooth
local AFlydSmooth = Class("AFlydSmooth")

function AFlydSmooth:GetSmoothList(list, p_maxCount, NUM_PER_SESS, aMapData)
    self.aMapData = aMapData
    if NUM_PER_SESS == nil or NUM_PER_SESS == 0 then
        NUM_PER_SESS = 13
    end
    NUM_PER_SESS = NUM_PER_SESS * 3

    local index = 1
    while (true) do
        if index >= #list - 2 then
            break
        end
        local curX = list[index]
        local curY = list[index + 2]

        local i = index + NUM_PER_SESS
        while (i > index) do
            if i > #list - 2 then
                i = #list - 2
            end

            if not self:CheckBlock(curX / 10, curY / 10, list[i] / 10, list[i + 2] / 10) then
                --print("before Remove #list == " .. tostring(#list) .. " StartRemoveIndex == " .. tostring(index + 3))
                for idx = 1, i - index - 3, 1 do
                    table.remove(list, index + 3)
                end
                --print("index == " .. index .. " rCount == " .. rCount .." afterRemove #list == " .. tostring(#list))
                index = index + 3
                break
            end

            if i == (index + 3) then
                index = index + 3
                break
            end

            i = i - 3
        end
    end
    return list
end

---AddPoint2
---@param list APoint2 k value
---@param x number
---@param y number
function AFlydSmooth:AddPoint2(list, x, y, dic)
    local key = APoint2.CreateKey(x, y)
    if dic[key] == nil then
        local p = APoint2.New(x, y)
        table.insert(list, p)
        dic[key] = p
    end
end

---CheckBlock
---@param startX number
---@param startY number
---@param endX number
---@param endY number
---@return boolean
function AFlydSmooth:CheckBlock(startX, startY, endX, endY)
    ---@type APoint2
    local startPoint = APoint2.New(startX, startY)
    ---@type APoint2
    local endPoint = APoint2.New(endX, endY)

    local minY = math.min(startPoint.y, endPoint.y);
    local maxY = math.max(startPoint.y, endPoint.y);
    local minX = math.min(startPoint.x, endPoint.x);
    local maxX = math.max(startPoint.x, endPoint.x);

    local pointDic = {}
    ---@type APoint2[]
    local pointList = {}
    self:AddPoint2(pointList, startPoint.x, startPoint.y, pointDic)
    self:AddPoint2(pointList, endPoint.x, endPoint.y, pointDic)

    if endPoint.x == startPoint.x then
        local x = endPoint.x
        for y = minY, maxY do
            self:AddPoint2(pointList, x, y, pointDic)
        end
    elseif endPoint.y == startPoint.y then
        local y = endPoint.y
        for x = minX, maxX do
            self:AddPoint2(pointList, x, y, pointDic)
        end
    else
        local x1 = startPoint.x + 0.5
        local y1 = startPoint.y + 0.5
        local x2 = endPoint.x + 0.5
        local y2 = endPoint.y + 0.5

        local dx = x2 * 10 - x1 * 10
        local dy = y2 * 10 - y1 * 10

        ---@type AFractionV2
        local fy = AFractionV2.New(y1 * 1000, 1000)
        ---@type AFractionV2
        local fx = AFractionV2.New(x1 * 1000, 1000)

        ---@type AFractionV2
        local K = AFractionV2.New(dy, dx)
        ---@type AFractionV2
        local k2 = AFractionV2.New(dx, dy)
        ---@type AFractionV2
        local B = AFractionV2.Subtract(fy, AFractionV2.Multiply(K, fx))

        for x = minX, maxX do
            local yyy = AFractionV2.Add(AFractionV2.Multiply(K, AFractionV2.New(x)), B):ToDouble()
            local y = math.floor(yyy)

            if y >= minY and y <= maxY then
                self:AddPoint2(pointList, x, y, pointDic)
                if x - 1 >= minX then
                    self:AddPoint2(pointList, x - 1, y, pointDic)
                end

                local iiy = math.floor(yyy * 1000)
                if y * 1000 == iiy and (y - 1 >= minY) then
                    self:AddPoint2(pointList, x - 1, y - 1, pointDic)
                end
            end
        end

        for y = minY, maxY do
            local xxx = AFractionV2.Multiply(AFractionV2.Subtract(AFractionV2.New(y), B), k2):ToDouble()
            local x = math.floor(xxx)
            if x >= minX and x <= maxX then
                self:AddPoint2(pointList, x, y, pointDic)
                if y - 1 >= minY then
                    self:AddPoint2(pointList, x, y - 1, pointDic)
                end

                local iix = math.floor(xxx * 1000)
                if x * 1000 == iix and (x - 1 >= minX) then
                    self:AddPoint2(pointList, x - 1, y - 1, pointDic)
                end
            end
        end

        --print("start log point list .............................................")
        --for i = 0, #pointList do
        --    print("x == " .. tostring(pointList[i].x) .. " v == " .. tostring(pointList[i].y))    
        --end
        --print("end log point list .............................................")
    end

    ---@param item1 APoint2
    ---@param item2 APoint2
    table.sort(pointList, function(item1, item2)
        local aa = item1:Distance2(startPoint)
        local bb = item2:Distance2(startPoint)
        return aa > bb
    end)

    for i = 1, #pointList do
        local a = pointList[i]
        if self.aMapData:IsBlock(a.x, a.y) then
            return true
        end

        if i < #pointList then
            local b = pointList[i + 1]
            local hx = math.floor((a.x + b.x) / 2)
            local hy = math.floor((a.y + b.y) / 2)
            if self.aMapData:IsBlock(hx, hy) then
                return true
            end
        end
    end
    return false
end

---@type AFlydSmooth
AFlydSmoothManager = AFlydSmooth.New()
