---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Bing Lau.
--- DateTime: 2021/5/20 11:46
---

local _errorFunc = LogError
local unpack = unpack or table.unpack

---异常捕获
function TryCatch(func, p1, ...)
    if func then
        if not App.isMacOrMacEditor then
            return xpcall(func, _errorFunc, p1, ...)
        else
            local status, ret = pcall(func, p1, ...)
            if status then
                return ret
            else
                PrintError("xpcall or pcall error. %s", ret)
                return nil
            end
        end
    end
end

function CallbackCall(callback, target, ...)
    --local args = {...}
    --for _, v in pairs(args) do
    --    Log(v)
    --end
    if callback then
        if target then
            TryCatch(callback, target, ...)
        else
            TryCatch(callback, ...)
        end
    end
end

function CallbackPack(callback, target, ...)
    --local args = {...}
    --for _, v in pairs(args) do
    --    Log(v)
    --end
    local params = SafePack(...)
    return function(...)
        local args = ConcatSafePack(params, SafePack(...))
        CallbackCall(callback, target, SafeUnpack(args))
    end
end

-- 规避原生pack的nil截断问题，SafePack与SafeUnpack要成对使用
function SafePack(...)
    local params = {...}
    params.n = select('#', ...)
    return params
end

-- 规避原生unpack的nil截断问题，SafePack与SafeUnpack要成对使用
function SafeUnpack(safe_pack_tb)
    return unpack(safe_pack_tb, 1, safe_pack_tb.n)
end

-- 对两个SafePack的表执行连接
function ConcatSafePack(safe_pack_l, safe_pack_r)
    local concat = {}
    for i = 1,safe_pack_l.n do
        concat[i] = safe_pack_l[i]
    end
    for i = 1,safe_pack_r.n do
        concat[safe_pack_l.n + i] = safe_pack_r[i]
    end
    concat.n = safe_pack_l.n + safe_pack_r.n
    return concat
end

-- 深拷贝对象
function DeepCopy(object)
    local lookup_table = {}

    local function _copy(object)
        if type(object) ~= "table" then
            return object
        elseif lookup_table[object] then
            return lookup_table[object]
        end

        local new_table = {}
        lookup_table[object] = new_table
        for index, value in pairs(object) do
            new_table[_copy(index)] = _copy(value)
        end

        return setmetatable(new_table, getmetatable(object))
    end

    return _copy(object)
end

---不重启Unity编辑器实现Lua热加载
function reimportInEditor(name)
    local package = package
    local old_module = package.loaded[name]
    if not old_module then
        print("[hotfix] " .. name)
        return
    end
    if old_module == true then
        -- 没有返回值
        local index = string.lastIndexOf(name, "%.")
        local moduleName = string.substr(name, index + 1)
        local old_table = _G[moduleName]
        if type(old_table) ~= "table" then
            return
        end
        package.loaded[name] = nil
        require(name)
        local new_table = _G[moduleName]
        for i, v in pairs(new_table) do
            if type(v) == "function" then
                old_table[i] = v
            end
        end
        _G[moduleName] = old_table
        package.loaded[name] = old_module
        print("[hotfix] " .. name)
    elseif type(old_module) == "table" then
       -- 返回module
        require(name)
        local new_module = package.loaded[name]
        for i, v in pairs(new_module) do
            if type(v) == "function" then
                old_module[i] = v
            end
        end
        package.loaded[name] = old_module
        print("[hotfix] "..name)
    end
end

---导入保护，模块存在才导入
function requireifExits(moduleName)
    local state, obj = pcall(require, moduleName)
    if state then
        return obj
    end
    return nil
end

function requireUnload(moduleName)
    local package = package
    package.loaded[moduleName] = nil
    package.preload[moduleName] = nil
end

--重新require一个lua文件，替代系统文件。
function reimport(name)
    local package = package
    package.loaded[name] = nil
    package.preload[name] = nil
    return require(name)
end
